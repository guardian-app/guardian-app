{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\nimport ReactNodeFormatter from \"./format/ReactNodeFormatter\";\nexport var EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nfunction serializeLogDataAsync(data, level) {\n  var serializedValues, includesStack, rawStack, syntheticError, stack, errorMessage, serializedError, error, _errorMessage, _serializedError;\n\n  return _regeneratorRuntime.async(function serializeLogDataAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          includesStack = false;\n\n          if (!_stackTraceLogsSupported()) {\n            _context.next = 32;\n            break;\n          }\n\n          if (!_isUnhandledPromiseRejection(data, level)) {\n            _context.next = 11;\n            break;\n          }\n\n          rawStack = data[0];\n          syntheticError = {\n            stack: rawStack\n          };\n          _context.next = 7;\n          return _regeneratorRuntime.awrap(_symbolicateErrorAsync(syntheticError));\n\n        case 7:\n          stack = _context.sent;\n\n          if (!stack.length) {\n            serializedValues = _stringifyLogData(data);\n          } else {\n            errorMessage = rawStack.split('\\n')[1];\n            serializedValues = [{\n              message: \"[Unhandled promise rejection: \" + errorMessage + \"]\",\n              stack: _formatStack(stack)\n            }];\n            includesStack = true;\n          }\n\n          _context.next = 30;\n          break;\n\n        case 11:\n          if (!(data.length === 1 && data[0] instanceof Error)) {\n            _context.next = 19;\n            break;\n          }\n\n          _context.next = 14;\n          return _regeneratorRuntime.awrap(_serializeErrorAsync(data[0]));\n\n        case 14:\n          serializedError = _context.sent;\n          serializedValues = [serializedError];\n          includesStack = serializedError.hasOwnProperty('stack');\n          _context.next = 30;\n          break;\n\n        case 19:\n          if (!(level === 'warn' || level === 'error')) {\n            _context.next = 29;\n            break;\n          }\n\n          error = _captureConsoleStackTrace();\n          _errorMessage = _stringifyLogData(data).join(', ');\n          _context.next = 24;\n          return _regeneratorRuntime.awrap(_serializeErrorAsync(error, _errorMessage));\n\n        case 24:\n          _serializedError = _context.sent;\n          serializedValues = [_serializedError];\n          includesStack = _serializedError.hasOwnProperty('stack');\n          _context.next = 30;\n          break;\n\n        case 29:\n          serializedValues = _stringifyLogData(data);\n\n        case 30:\n          _context.next = 33;\n          break;\n\n        case 32:\n          serializedValues = _stringifyLogData(data);\n\n        case 33:\n          return _context.abrupt(\"return\", {\n            body: _toConsumableArray(serializedValues),\n            includesStack: includesStack\n          });\n\n        case 34:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _stringifyLogData(data) {\n  return data.map(function (item) {\n    if (typeof item === 'string') {\n      return item;\n    } else {\n      var LOG_MESSAGE_MAX_LENGTH = 10000;\n      var result = prettyFormat(item, {\n        plugins: [ReactNodeFormatter]\n      });\n\n      if (result.length > LOG_MESSAGE_MAX_LENGTH) {\n        var truncatedResult = result.substring(0, LOG_MESSAGE_MAX_LENGTH);\n        truncatedResult += \"...(truncated to the first \" + LOG_MESSAGE_MAX_LENGTH + \" characters)\";\n        return truncatedResult;\n      } else {\n        return result;\n      }\n    }\n  });\n}\n\nfunction _serializeErrorAsync(error, message) {\n  var messageParts, firstUselessLine, stack, formattedStack;\n  return _regeneratorRuntime.async(function _serializeErrorAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (message == null) {\n            message = error.message;\n          }\n\n          messageParts = message.split('\\n');\n          firstUselessLine = messageParts.indexOf('This error is located at:');\n\n          if (firstUselessLine > 0) {\n            message = messageParts.slice(0, firstUselessLine - 1).join('\\n');\n          }\n\n          if (!(!error.stack || !error.stack.length)) {\n            _context2.next = 6;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", prettyFormat(error));\n\n        case 6:\n          _context2.next = 8;\n          return _regeneratorRuntime.awrap(_symbolicateErrorAsync(error));\n\n        case 8:\n          stack = _context2.sent;\n          formattedStack = _formatStack(stack);\n          return _context2.abrupt(\"return\", {\n            message: message,\n            stack: formattedStack\n          });\n\n        case 11:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _symbolicateErrorAsync(error) {\n  var parsedStack, symbolicatedStack;\n  return _regeneratorRuntime.async(function _symbolicateErrorAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          parsedStack = parseErrorStack(error);\n          _context3.prev = 1;\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(symbolicateStackTrace(parsedStack));\n\n        case 4:\n          symbolicatedStack = _context3.sent;\n          _context3.next = 10;\n          break;\n\n        case 7:\n          _context3.prev = 7;\n          _context3.t0 = _context3[\"catch\"](1);\n          return _context3.abrupt(\"return\", parsedStack);\n\n        case 10:\n          if (symbolicatedStack) {\n            _context3.next = 12;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", parsedStack);\n\n        case 12:\n          return _context3.abrupt(\"return\", symbolicatedStack.map(_removeProjectRoot));\n\n        case 13:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[1, 7]], Promise);\n}\n\nfunction _formatStack(stack) {\n  return stack.map(function (frame) {\n    var line = frame.file + \":\" + frame.lineNumber;\n\n    if (frame.column != null) {\n      line += \":\" + frame.column;\n    }\n\n    line += \" in \" + frame.methodName;\n    return line;\n  }).join('\\n');\n}\n\nfunction _removeProjectRoot(frame) {\n  var filename = frame.file;\n\n  if (filename == null) {\n    return frame;\n  }\n\n  var projectRoot = _getProjectRoot();\n\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\nfunction _stackTraceLogsSupported() {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data, level) {\n  return level === 'warn' && typeof data[0] === 'string' && /^Possible Unhandled Promise Rejection/.test(data[0]);\n}\n\nfunction _captureConsoleStackTrace() {\n  try {\n    throw new Error();\n  } catch (error) {\n    var stackLines = error.stack.split('\\n');\n    var consoleMethodIndex = stackLines.findIndex(function (frame) {\n      return frame.includes(EXPO_CONSOLE_METHOD_NAME);\n    });\n\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n\n    return error;\n  }\n}\n\nfunction _getProjectRoot() {\n  return Constants.manifest && Constants.manifest.developer ? Constants.manifest.developer.projectRoot : null;\n}\n\nexport default {\n  serializeLogDataAsync: serializeLogDataAsync\n};","map":{"version":3,"sources":["../../src/logs/LogSerialization.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack, { StackFrame } from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\n\nimport { LogData, LogLevel } from './RemoteLogging';\nimport ReactNodeFormatter from './format/ReactNodeFormatter';\n\ntype SerializedData = {\n  body: LogData[];\n  includesStack: boolean;\n};\n\nexport const EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nasync function serializeLogDataAsync(data: unknown[], level: LogLevel): Promise<SerializedData> {\n  let serializedValues: readonly LogData[];\n  let includesStack = false;\n\n  if (_stackTraceLogsSupported()) {\n    if (_isUnhandledPromiseRejection(data, level)) {\n      let rawStack = data[0] as string;\n      let syntheticError = { stack: rawStack };\n      let stack = await _symbolicateErrorAsync(syntheticError as Error);\n\n      if (!stack.length) {\n        serializedValues = _stringifyLogData(data);\n      } else {\n        // NOTE: This doesn't handle error messages with newlines\n        let errorMessage = rawStack.split('\\n')[1];\n        serializedValues = [\n          {\n            message: `[Unhandled promise rejection: ${errorMessage}]`,\n            stack: _formatStack(stack),\n          },\n        ];\n        includesStack = true;\n      }\n    } else if (data.length === 1 && data[0] instanceof Error) {\n      // When there's only one argument to the log function and that argument is an error, we\n      // include the error's stack. If there's more than one argument then we don't include the\n      // stack because it's not easy to display nicely in our current UI.\n\n      let serializedError = await _serializeErrorAsync(data[0] as Error);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else if (level === 'warn' || level === 'error') {\n      // For console.warn and console.error it is usually useful to know the stack that leads to the\n      // warning or error, so we provide this information to help out with debugging\n\n      let error = _captureConsoleStackTrace();\n      // [\"hello\", \"world\"] becomes \"hello, world\"\n      let errorMessage = _stringifyLogData(data).join(', ');\n\n      let serializedError = await _serializeErrorAsync(error, errorMessage);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n  } else {\n    serializedValues = _stringifyLogData(data);\n  }\n\n  return {\n    body: [...serializedValues],\n    includesStack,\n  };\n}\n\nfunction _stringifyLogData(data: unknown[]): string[] {\n  return data.map(item => {\n    if (typeof item === 'string') {\n      return item;\n    } else {\n      // define the max length for log msg to be first 10000 characters\n      const LOG_MESSAGE_MAX_LENGTH = 10000;\n      let result = prettyFormat(item, { plugins: [ReactNodeFormatter] });\n      // check the size of string returned\n      if (result.length > LOG_MESSAGE_MAX_LENGTH) {\n        let truncatedResult = result.substring(0, LOG_MESSAGE_MAX_LENGTH);\n        // truncate the result string to the max length\n        truncatedResult += `...(truncated to the first ${LOG_MESSAGE_MAX_LENGTH} characters)`;\n        return truncatedResult;\n      } else {\n        return result;\n      }\n    }\n  });\n}\n\nasync function _serializeErrorAsync(error: Error, message?: string): Promise<LogData> {\n  if (message == null) {\n    message = error.message;\n  }\n\n  // note(brentvatne): React Native currently appends part of the stack inside of\n  // the error message itself for some reason. This is just confusing and we don't\n  // want to include it in the expo-cli output\n  let messageParts = message.split('\\n');\n  let firstUselessLine = messageParts.indexOf('This error is located at:');\n  if (firstUselessLine > 0) {\n    message = messageParts.slice(0, firstUselessLine - 1).join('\\n');\n  }\n\n  if (!error.stack || !error.stack.length) {\n    return prettyFormat(error);\n  }\n\n  let stack = await _symbolicateErrorAsync(error);\n  let formattedStack = _formatStack(stack);\n\n  return { message, stack: formattedStack };\n}\n\nasync function _symbolicateErrorAsync(error: Error): Promise<StackFrame[]> {\n  let parsedStack = parseErrorStack(error);\n  let symbolicatedStack: StackFrame[] | null;\n  try {\n    symbolicatedStack = await symbolicateStackTrace(parsedStack);\n  } catch (error) {\n    return parsedStack;\n  }\n\n  // In this context an unsymbolicated stack is better than no stack\n  if (!symbolicatedStack) {\n    return parsedStack;\n  }\n\n  // Clean the stack trace\n  return symbolicatedStack.map(_removeProjectRoot);\n}\n\nfunction _formatStack(stack: StackFrame[]): string {\n  return stack\n    .map(frame => {\n      let line = `${frame.file}:${frame.lineNumber}`;\n      if (frame.column != null) {\n        line += `:${frame.column}`;\n      }\n      line += ` in ${frame.methodName}`;\n      return line;\n    })\n    .join('\\n');\n}\n\nfunction _removeProjectRoot(frame: StackFrame): StackFrame {\n  let filename = frame.file;\n  if (filename == null) {\n    return frame;\n  }\n\n  let projectRoot = _getProjectRoot();\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\n/**\n * Returns whether the development server that served this project supports logs with a stack trace.\n * Specifically, the version of Expo CLI that includes `projectRoot` in the manifest also accepts\n * payloads of the form:\n *\n * {\n *   includesStack: boolean, body: [{ message: string, stack: string }],\n * }\n */\nfunction _stackTraceLogsSupported(): boolean {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data: unknown[], level: LogLevel): boolean {\n  return (\n    level === 'warn' &&\n    typeof data[0] === 'string' &&\n    /^Possible Unhandled Promise Rejection/.test(data[0] as string)\n  );\n}\n\nfunction _captureConsoleStackTrace(): Error {\n  try {\n    throw new Error();\n  } catch (error) {\n    let stackLines = error.stack.split('\\n');\n    let consoleMethodIndex = stackLines.findIndex(frame =>\n      frame.includes(EXPO_CONSOLE_METHOD_NAME)\n    );\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n    return error;\n  }\n}\n\nfunction _getProjectRoot(): string | null {\n  return Constants.manifest && Constants.manifest.developer\n    ? Constants.manifest.developer.projectRoot\n    : null;\n}\n\nexport default {\n  serializeLogDataAsync,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}