{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport uuidv4 from 'uuid/v4';\nimport LogSerialization from \"./LogSerialization\";\n\nvar _sessionId = uuidv4();\n\nvar _logQueue = [];\n\nvar _transportEventEmitter = new EventEmitter();\n\nvar _logCounter = 0;\nvar _isSendingLogs = false;\nvar _completionPromise = null;\nvar _resolveCompletion2 = null;\n\nfunction enqueueRemoteLogAsync(level, additionalFields, data) {\n  var warning, lines, _await$LogSerializati, body, includesStack;\n\n  return _regeneratorRuntime.async(function enqueueRemoteLogAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!_isReactNativeWarning(data)) {\n            _context.next = 8;\n            break;\n          }\n\n          if (!(data.length === 0)) {\n            _context.next = 3;\n            break;\n          }\n\n          throw new Error(\"Warnings must include log arguments\");\n\n        case 3:\n          warning = data[0];\n\n          if (!(typeof warning !== 'string')) {\n            _context.next = 6;\n            break;\n          }\n\n          throw new TypeError(\"The log argument for a warning must be a string\");\n\n        case 6:\n          lines = warning.split('\\n');\n\n          if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n            data[0] = lines[0];\n          }\n\n        case 8:\n          _context.next = 10;\n          return _regeneratorRuntime.awrap(LogSerialization.serializeLogDataAsync(data, level));\n\n        case 10:\n          _await$LogSerializati = _context.sent;\n          body = _await$LogSerializati.body;\n          includesStack = _await$LogSerializati.includesStack;\n\n          _logQueue.push(_objectSpread({\n            count: _logCounter++,\n            level: level,\n            body: body,\n            includesStack: includesStack\n          }, additionalFields));\n\n          _sendRemoteLogsAsync().catch(function (error) {\n            setImmediate(function () {\n              throw error;\n            });\n          });\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _sendRemoteLogsAsync() {\n  var batch, logUrl;\n  return _regeneratorRuntime.async(function _sendRemoteLogsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(_isSendingLogs || !_logQueue.length)) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.abrupt(\"return\");\n\n        case 2:\n          batch = _logQueue.splice(0);\n          logUrl = Constants.manifest.logUrl;\n\n          if (!(typeof logUrl !== 'string')) {\n            _context2.next = 6;\n            break;\n          }\n\n          throw new Error('The Expo project manifest must specify `logUrl`');\n\n        case 6:\n          _isSendingLogs = true;\n          _context2.prev = 7;\n          _context2.next = 10;\n          return _regeneratorRuntime.awrap(_sendNextLogBatchAsync(batch, logUrl));\n\n        case 10:\n          _context2.prev = 10;\n          _isSendingLogs = false;\n          return _context2.finish(10);\n\n        case 13:\n          if (!_logQueue.length) {\n            _context2.next = 17;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", _sendRemoteLogsAsync());\n\n        case 17:\n          if (_resolveCompletion2) {\n            _resolveCompletion2();\n          }\n\n        case 18:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[7,, 10, 13]], Promise);\n}\n\nfunction _sendNextLogBatchAsync(batch, logUrl) {\n  var response, headers, success;\n  return _regeneratorRuntime.async(function _sendNextLogBatchAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          headers = {\n            'Content-Type': 'application/json',\n            Connection: 'keep-alive',\n            'Proxy-Connection': 'keep-alive',\n            Accept: 'application/json',\n            'Device-Id': Constants.installationId,\n            'Session-Id': _sessionId\n          };\n\n          if (Constants.deviceName) {\n            headers['Device-Name'] = Constants.deviceName;\n          }\n\n          _context3.prev = 2;\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(fetch(logUrl, {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify(batch)\n          }));\n\n        case 5:\n          response = _context3.sent;\n          _context3.next = 12;\n          break;\n\n        case 8:\n          _context3.prev = 8;\n          _context3.t0 = _context3[\"catch\"](2);\n\n          _transportEventEmitter.emit('error', {\n            error: _context3.t0\n          });\n\n          return _context3.abrupt(\"return\");\n\n        case 12:\n          success = response.status >= 200 && response.status < 300;\n\n          if (!success) {\n            _transportEventEmitter.emit('error', {\n              error: new Error(\"An HTTP error occurred when sending remote logs\"),\n              response: response\n            });\n          }\n\n        case 14:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[2, 8]], Promise);\n}\n\nfunction addTransportErrorListener(listener) {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data) {\n  var message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync: enqueueRemoteLogAsync,\n  addTransportErrorListener: addTransportErrorListener\n};\nexport function __waitForEmptyLogQueueAsync() {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(function (resolve) {\n    _resolveCompletion2 = function _resolveCompletion() {\n      invariant(!_isSendingLogs, \"Must not be sending logs at completion\");\n      invariant(!_logQueue.length, \"Log queue must be empty at completion\");\n      _completionPromise = null;\n      _resolveCompletion2 = null;\n      resolve();\n    };\n  });\n  return _completionPromise;\n}","map":{"version":3,"sources":["../../src/logs/RemoteLogging.ts"],"names":[],"mappings":";;;;;;;AAAA,OAAO,SAAP,MAAsB,gBAAtB;AACA,SAAS,YAAT,QAAgD,WAAhD;AACA,OAAO,SAAP,MAAsB,WAAtB;AACA,OAAO,MAAP,MAAmB,SAAnB;AAEA,OAAO,gBAAP;;AAuBA,IAAM,UAAU,GAAG,MAAM,EAAzB;;AACA,IAAM,SAAS,GAAe,EAA9B;;AACA,IAAM,sBAAsB,GAAG,IAAI,YAAJ,EAA/B;;AAEA,IAAI,WAAW,GAAG,CAAlB;AACA,IAAI,cAAc,GAAG,KAArB;AACA,IAAI,kBAAkB,GAAyB,IAA/C;AACA,IAAI,mBAAkB,GAAwB,IAA9C;;AAEA,SAAe,qBAAf,CACE,KADF,EAEE,gBAFF,EAGE,IAHF;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,eAKM,qBAAqB,CAAC,IAAD,CAL3B;AAAA;AAAA;AAAA;;AAAA,gBAOQ,IAAI,CAAC,MAAL,KAAgB,CAPxB;AAAA;AAAA;AAAA;;AAAA,gBAQY,IAAI,KAAJ,uCARZ;;AAAA;AAUU,UAAA,OAVV,GAUoB,IAAI,CAAC,CAAD,CAVxB;;AAAA,gBAWQ,OAAO,OAAP,KAAmB,QAX3B;AAAA;AAAA;AAAA;;AAAA,gBAYY,IAAI,SAAJ,mDAZZ;;AAAA;AAcU,UAAA,KAdV,GAckB,OAAO,CAAC,KAAR,CAAc,IAAd,CAdlB;;AAeI,cAAI,KAAK,CAAC,MAAN,GAAe,CAAf,IAAoB,UAAU,IAAV,CAAe,KAAK,CAAC,CAAD,CAApB,CAAxB,EAAkD;AAChD,YAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,KAAK,CAAC,CAAD,CAAf;AACD;;AAjBL;AAAA;AAAA,2CAoBsC,gBAAgB,CAAC,qBAAjB,CAAuC,IAAvC,EAA6C,KAA7C,CApBtC;;AAAA;AAAA;AAoBQ,UAAA,IApBR,yBAoBQ,IApBR;AAoBc,UAAA,aApBd,yBAoBc,aApBd;;AAsBE,UAAA,SAAS,CAAC,IAAV;AACE,YAAA,KAAK,EAAE,WAAW,EADpB;AAEE,YAAA,KAAK,EAAL,KAFF;AAGE,YAAA,IAAI,EAAJ,IAHF;AAIE,YAAA,aAAa,EAAb;AAJF,aAKK,gBALL;;AASA,UAAA,oBAAoB,GAAG,KAAvB,CAA6B,UAAA,KAAK,EAAG;AACnC,YAAA,YAAY,CAAC,YAAK;AAChB,oBAAM,KAAN;AACD,aAFW,CAAZ;AAGD,WAJD;;AA/BF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCA,SAAe,oBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBACM,cAAc,IAAI,CAAC,SAAS,CAAC,MADnC;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAOM,UAAA,KAPN,GAOc,SAAS,CAAC,MAAV,CAAiB,CAAjB,CAPd;AASQ,UAAA,MATR,GASmB,SAAS,CAAC,QAT7B,CASQ,MATR;;AAAA,gBAUM,OAAO,MAAP,KAAkB,QAVxB;AAAA;AAAA;AAAA;;AAAA,gBAWU,IAAI,KAAJ,CAAU,iDAAV,CAXV;;AAAA;AAcE,UAAA,cAAc,GAAG,IAAjB;AAdF;AAAA;AAAA,2CAgBU,sBAAsB,CAAC,KAAD,EAAQ,MAAR,CAhBhC;;AAAA;AAAA;AAkBI,UAAA,cAAc,GAAG,KAAjB;AAlBJ;;AAAA;AAAA,eAqBM,SAAS,CAAC,MArBhB;AAAA;AAAA;AAAA;;AAAA,4CAsBW,oBAAoB,EAtB/B;;AAAA;AAuBS,cAAI,mBAAJ,EAAwB;AAC7B,YAAA,mBAAkB;AACnB;;AAzBH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4BA,SAAe,sBAAf,CAAsC,KAAtC,EAAyD,MAAzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAGM,UAAA,OAHN,GAGgB;AACZ,4BAAgB,kBADJ;AAEZ,YAAA,UAAU,EAAE,YAFA;AAGZ,gCAAoB,YAHR;AAIZ,YAAA,MAAM,EAAE,kBAJI;AAKZ,yBAAa,SAAS,CAAC,cALX;AAMZ,0BAAc;AANF,WAHhB;;AAWE,cAAI,SAAS,CAAC,UAAd,EAA0B;AACxB,YAAA,OAAO,CAAC,aAAD,CAAP,GAAyB,SAAS,CAAC,UAAnC;AACD;;AAbH;AAAA;AAAA,2CAeqB,KAAK,CAAC,MAAD,EAAS;AAC7B,YAAA,MAAM,EAAE,MADqB;AAE7B,YAAA,OAAO,EAAP,OAF6B;AAG7B,YAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,KAAf;AAHuB,WAAT,CAf1B;;AAAA;AAeI,UAAA,QAfJ;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAqBI,UAAA,sBAAsB,CAAC,IAAvB,CAA4B,OAA5B,EAAqC;AAAE,YAAA,KAAK;AAAP,WAArC;;AArBJ;;AAAA;AAyBM,UAAA,OAzBN,GAyBgB,QAAQ,CAAC,MAAT,IAAmB,GAAnB,IAA0B,QAAQ,CAAC,MAAT,GAAkB,GAzB5D;;AA0BE,cAAI,CAAC,OAAL,EAAc;AACZ,YAAA,sBAAsB,CAAC,IAAvB,CAA4B,OAA5B,EAAqC;AACnC,cAAA,KAAK,EAAE,IAAI,KAAJ,mDAD4B;AAEnC,cAAA,QAAQ,EAAR;AAFmC,aAArC;AAID;;AA/BH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkCA,SAAS,yBAAT,CAAmC,QAAnC,EAAmE;AACjE,SAAO,sBAAsB,CAAC,WAAvB,CAAmC,OAAnC,EAA4C,QAA5C,CAAP;AACD;;AAED,SAAS,qBAAT,CAA+B,IAA/B,EAA8C;AAE5C,MAAI,OAAO,GAAG,IAAI,CAAC,CAAD,CAAlB;AACA,SAAO,IAAI,CAAC,MAAL,KAAgB,CAAhB,IAAqB,OAAO,OAAP,KAAmB,QAAxC,IAAoD,OAAO,CAAC,UAAR,CAAmB,WAAnB,CAA3D;AACD;;AAED,eAAe;AACb,EAAA,qBAAqB,EAArB,qBADa;AAEb,EAAA,yBAAyB,EAAzB;AAFa,CAAf;AASA,OAAM,SAAU,2BAAV,GAAqC;AACzC,MAAI,kBAAJ,EAAwB;AACtB,WAAO,kBAAP;AACD;;AAED,MAAI,CAAC,cAAD,IAAmB,CAAC,SAAS,CAAC,MAAlC,EAA0C;AACxC,WAAO,OAAO,CAAC,OAAR,EAAP;AACD;;AAED,EAAA,kBAAkB,GAAG,IAAI,OAAJ,CAAY,UAAA,OAAO,EAAG;AACzC,IAAA,mBAAkB,GAAG,8BAAK;AACxB,MAAA,SAAS,CAAC,CAAC,cAAF,2CAAT;AACA,MAAA,SAAS,CAAC,CAAC,SAAS,CAAC,MAAZ,0CAAT;AAEA,MAAA,kBAAkB,GAAG,IAArB;AACA,MAAA,mBAAkB,GAAG,IAArB;AAEA,MAAA,OAAO;AACR,KARD;AASD,GAVoB,CAArB;AAWA,SAAO,kBAAP;AACD","sourcesContent":["import Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport uuidv4 from 'uuid/v4';\n\nimport LogSerialization from './LogSerialization';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number;\n  level: LogLevel;\n  body: LogData[];\n  includesStack: boolean;\n  groupDepth?: number;\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean;\n  groupDepth?: number;\n  groupCollapsed?: boolean;\n};\n\nexport type LogData = string | LogErrorData;\nexport type LogErrorData = { message: string; stack: string };\n\ntype TransportErrorListener = (event: { error: Error; response?: Response }) => void;\n\nconst _sessionId = uuidv4();\nconst _logQueue: LogEntry[] = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: Promise<void> | null = null;\nlet _resolveCompletion: (() => void) | null = null;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: unknown[]\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n    const warning = data[0];\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  let { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch(error => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  let batch = _logQueue.splice(0);\n\n  let { logUrl } = Constants.manifest;\n  if (typeof logUrl !== 'string') {\n    throw new Error('The Expo project manifest must specify `logUrl`');\n  }\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: LogEntry[], logUrl: string): Promise<void> {\n  let response;\n\n  let headers = {\n    'Content-Type': 'application/json',\n    Connection: 'keep-alive',\n    'Proxy-Connection': 'keep-alive',\n    Accept: 'application/json',\n    'Device-Id': Constants.installationId,\n    'Session-Id': _sessionId,\n  };\n  if (Constants.deviceName) {\n    headers['Device-Name'] = Constants.deviceName;\n  }\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  let success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: unknown[]): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  let message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}