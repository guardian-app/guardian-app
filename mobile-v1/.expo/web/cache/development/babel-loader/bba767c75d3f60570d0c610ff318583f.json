{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nexport default function getStateFromPath(path) {\n  var _ref;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var initialRoutes = [];\n\n  var configs = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(options).map(function (key) {\n    return createNormalizedConfigs(key, options, [], initialRoutes);\n  })));\n\n  configs.sort(function (config1, config2) {\n    return config2.pattern.split('/').length - config1.pattern.split('/').length;\n  });\n  var remaining = path.replace(/\\/+/g, '/').replace(/^\\//, '').replace(/\\?.*$/, '');\n  remaining = remaining.endsWith('/') ? remaining : \"\".concat(remaining, \"/\");\n\n  if (remaining === '/') {\n    var match = configs.find(function (config) {\n      return config.pattern === '' && config.routeNames.every(function (name) {\n        var _configs$find;\n\n        return !((_configs$find = configs.find(function (c) {\n          return c.screen === name;\n        })) === null || _configs$find === void 0 ? void 0 : _configs$find.pattern);\n      });\n    });\n\n    if (match) {\n      return createNestedStateObject(match.routeNames, initialRoutes, parseQueryParams(path, match.parse));\n    }\n\n    return undefined;\n  }\n\n  var result;\n  var current;\n\n  while (remaining) {\n    var routeNames = void 0;\n\n    var _params = void 0;\n\n    var _loop2 = function _loop2(config) {\n      if (!config.match) {\n        return \"continue\";\n      }\n\n      var match = remaining.match(config.match);\n\n      if (match) {\n        routeNames = _toConsumableArray(config.routeNames);\n        var paramPatterns = config.pattern.split('/').filter(function (p) {\n          return p.startsWith(':');\n        });\n\n        if (paramPatterns.length) {\n          _params = paramPatterns.reduce(function (acc, p, i) {\n            var key = p.replace(/^:/, '').replace(/\\?$/, '');\n            var value = match[(i + 1) * 2].replace(/\\//, '');\n\n            if (value) {\n              acc[key] = config.parse && config.parse[key] ? config.parse[key](value) : value;\n            }\n\n            return acc;\n          }, {});\n        }\n\n        remaining = remaining.replace(match[1], '');\n        return \"break\";\n      }\n    };\n\n    _loop: for (var _iterator = _createForOfIteratorHelperLoose(configs), _step; !(_step = _iterator()).done;) {\n      var config = _step.value;\n\n      var _ret = _loop2(config);\n\n      switch (_ret) {\n        case \"continue\":\n          continue;\n\n        case \"break\":\n          break _loop;\n      }\n    }\n\n    if (routeNames === undefined) {\n      var segments = remaining.split('/');\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    var state = createNestedStateObject(routeNames, initialRoutes, _params);\n\n    if (current) {\n      var _current2;\n\n      while ((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index || 0].state) {\n        var _current;\n\n        current = current.routes[current.index || 0].state;\n      }\n\n      current.routes[((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.index) || 0].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  var route = findFocusedRoute(current);\n  var params = parseQueryParams(path, findParseConfigForRoute(route.name, configs));\n\n  if (params) {\n    route.params = _objectSpread(_objectSpread({}, route.params), params);\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(key, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 ? arguments[3] : undefined;\n  var configs = [];\n  routeNames.push(key);\n  var value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    configs.push(createConfigItem(key, routeNames, value));\n  } else if (typeof value === 'object') {\n    if (typeof value.path === 'string') {\n      configs.push(createConfigItem(key, routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens)\n        });\n      }\n\n      Object.keys(value.screens).forEach(function (nestedConfig) {\n        var result = createNormalizedConfigs(nestedConfig, value.screens, routeNames, initials);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n\n  routeNames.pop();\n  return configs;\n}\n\nfunction createConfigItem(screen, routeNames, pattern, parse) {\n  var match = pattern ? new RegExp(\"^(\".concat(pattern.split('/').map(function (it) {\n    if (it.startsWith(':')) {\n      return \"(([^/]+\\\\/)\".concat(it.endsWith('?') ? '?' : '', \")\");\n    }\n\n    return \"\".concat(escape(it), \"\\\\/\");\n  }).join(''), \")\")) : null;\n  return {\n    screen: screen,\n    match: match,\n    pattern: pattern,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse\n  };\n}\n\nfunction findParseConfigForRoute(routeName, flatConfig) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(flatConfig), _step2; !(_step2 = _iterator2()).done;) {\n    var config = _step2.value;\n\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n}\n\nfunction findInitialRoute(routeName, initialRoutes) {\n  for (var _iterator3 = _createForOfIteratorHelperLoose(initialRoutes), _step3; !(_step3 = _iterator3()).done;) {\n    var config = _step3.value;\n\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName ? undefined : config.initialRouteName;\n    }\n  }\n\n  return undefined;\n}\n\nfunction createStateObject(initialRoute, routeName, isEmpty, params) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, {\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    } else {\n      return {\n        routes: [{\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    }\n  }\n}\n\nfunction createNestedStateObject(routeNames, initialRoutes, params) {\n  var state;\n  var routeName = routeNames.shift();\n  var initialRoute = findInitialRoute(routeName, initialRoutes);\n  state = createStateObject(initialRoute, routeName, routeNames.length === 0, params);\n\n  if (routeNames.length > 0) {\n    var nestedState = state;\n\n    while (routeName = routeNames.shift()) {\n      initialRoute = findInitialRoute(routeName, initialRoutes);\n      nestedState.routes[nestedState.index || 0].state = createStateObject(initialRoute, routeName, routeNames.length === 0, params);\n\n      if (routeNames.length > 0) {\n        nestedState = nestedState.routes[nestedState.index || 0].state;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state) {\n  var _current4;\n\n  var current = state;\n\n  while ((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.routes[current.index || 0].state) {\n    var _current3;\n\n    current = current.routes[current.index || 0].state;\n  }\n\n  var route = current.routes[((_current4 = current) === null || _current4 === void 0 ? void 0 : _current4.index) || 0];\n  return route;\n}\n\nfunction parseQueryParams(path, parseConfig) {\n  var query = path.split('?')[1];\n  var params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}","map":{"version":3,"sources":["getStateFromPath.tsx"],"names":["options","initialRoutes","configs","Object","key","createNormalizedConfigs","config2","config1","remaining","match","config","name","c","createNestedStateObject","parseQueryParams","routeNames","params","paramPatterns","p","value","i","acc","segments","decodeURIComponent","state","current","result","route","findFocusedRoute","findParseConfigForRoute","routeConfig","createConfigItem","initials","initialRouteName","connectedRoutes","nestedConfig","pattern","it","escape","screen","parse","routeName","index","routes","initialRoute","findInitialRoute","createStateObject","nestedState","query","path","queryString","parseConfig"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  screen: string;\n  match: RegExp | null;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  // sort configs so the most exhaustive is always first to be chosen\n  configs.sort(\n    (config1, config2) =>\n      config2.pattern.split('/').length - config1.pattern.split('/').length\n  );\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.pattern === '' &&\n        config.routeNames.every(\n          // make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.pattern\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames,\n        initialRoutes,\n        parseQueryParams(path, match.parse)\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      if (!config.match) {\n        continue;\n      }\n\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '').replace(/\\?$/, '');\n            const value = match[(i + 1) * 2].replace(/\\//, ''); // The param segments appear every second item starting from 2 in the regex match result\n\n            if (value) {\n              acc[key] =\n                config.parse && config.parse[key]\n                  ? config.parse[key](value)\n                  : value;\n            }\n\n            return acc;\n          }, {});\n        }\n\n        remaining = remaining.replace(match[1], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(routeNames, initialRoutes, params);\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    configs.push(createConfigItem(key, routeNames, value));\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof value.path === 'string') {\n      configs.push(createConfigItem(key, routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : null;\n\n  return {\n    screen,\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createStateObject(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n\nfunction createNestedStateObject(\n  routeNames: string[],\n  initialRoutes: InitialRouteConfig[],\n  params: object | undefined\n) {\n  let state: InitialState;\n  let routeName = routeNames.shift() as string;\n  let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    routeName,\n    routeNames.length === 0,\n    params\n  );\n\n  if (routeNames.length > 0) {\n    let nestedState = state;\n\n    while ((routeName = routeNames.shift() as string)) {\n      initialRoute = findInitialRoute(routeName, initialRoutes);\n      nestedState.routes[nestedState.index || 0].state = createStateObject(\n        initialRoute,\n        routeName,\n        routeNames.length === 0,\n        params\n      );\n      if (routeNames.length > 0) {\n        nestedState = nestedState.routes[nestedState.index || 0]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state: InitialState) {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n}\n\nfunction parseQueryParams(\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}