{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport queryString from 'query-string';\nexport default function getPathFromState(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n\n  var path = '/';\n  var current = state;\n\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var currentOptions = options;\n    var pattern = route.name;\n    var nestedRouteNames = '';\n\n    while (route.name in currentOptions) {\n      if (typeof currentOptions[route.name] === 'string') {\n        pattern = currentOptions[route.name];\n        break;\n      } else if (typeof currentOptions[route.name] === 'object') {\n        if (!currentOptions[route.name].screens) {\n          pattern = currentOptions[route.name].path;\n          nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n          break;\n        } else {\n          if (route.state === undefined) {\n            pattern = currentOptions[route.name].path;\n            nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n            break;\n          } else {\n            index = typeof route.state.index === 'number' ? route.state.index : 0;\n            var nextRoute = route.state.routes[index];\n            var deeperConfig = currentOptions[route.name].screens;\n\n            if (nextRoute.name in deeperConfig) {\n              nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n              route = nextRoute;\n              currentOptions = deeperConfig;\n            } else {\n              pattern = currentOptions[route.name].path;\n              nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.substring(1);\n    }\n\n    var config = currentOptions[route.name] !== undefined ? currentOptions[route.name].stringify : undefined;\n    var params = route.params ? Object.entries(route.params).reduce(function (acc, _ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          value = _ref2[1];\n\n      acc[key] = (config === null || config === void 0 ? void 0 : config[key]) ? config[key](value) : String(value);\n      return acc;\n    }, {}) : undefined;\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(function (p) {\n        var name = p.replace(/^:/, '').replace(/\\?$/, '');\n\n        if (params && name in params && p.startsWith(':')) {\n          var value = params[name];\n          delete params[name];\n          return encodeURIComponent(value);\n        } else if (p.endsWith('?')) {\n          return '';\n        }\n\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (params) {\n      for (var param in params) {\n        if (params[param] === 'undefined') {\n          delete params[param];\n        }\n      }\n\n      var query = queryString.stringify(params);\n\n      if (query) {\n        path += \"?\".concat(query);\n      }\n    }\n\n    current = route.state;\n  };\n\n  while (current) {\n    _loop();\n  }\n\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["options","state","Error","path","current","index","route","currentOptions","pattern","nestedRouteNames","nextRoute","deeperConfig","config","params","Object","acc","String","p","name","value","encodeURIComponent","query","queryString"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        stringify?: StringifyConfig;\n        screens?: Options;\n      };\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state?: State,\n  options: Options = {}\n): string {\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n  let path = '/';\n\n  let current: State | undefined = state;\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n    let currentOptions = options;\n    let pattern = route.name;\n    // we keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = '';\n\n    while (route.name in currentOptions) {\n      if (typeof currentOptions[route.name] === 'string') {\n        pattern = currentOptions[route.name] as string;\n        break;\n      } else if (typeof currentOptions[route.name] === 'object') {\n        // if there is no `screens` property, we return pattern\n        if (\n          !(currentOptions[route.name] as {\n            screens: Options;\n          }).screens\n        ) {\n          pattern = (currentOptions[route.name] as { path: string }).path;\n          nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n          break;\n        } else {\n          // if it is the end of state, we return pattern\n          if (route.state === undefined) {\n            pattern = (currentOptions[route.name] as { path: string }).path;\n            nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n            break;\n          } else {\n            index =\n              typeof route.state.index === 'number' ? route.state.index : 0;\n            const nextRoute = route.state.routes[index];\n            const deeperConfig = (currentOptions[route.name] as {\n              screens: Options;\n            }).screens;\n            // if there is config for next route name, we go deeper\n            if (nextRoute.name in deeperConfig) {\n              nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n              route = nextRoute as Route<string> & { state?: State };\n              currentOptions = deeperConfig;\n            } else {\n              // if not, there is no sense in going deeper in config\n              pattern = (currentOptions[route.name] as { path: string }).path;\n              nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      // cut the first `/`\n      pattern = nestedRouteNames.substring(1);\n    }\n\n    const config =\n      currentOptions[route.name] !== undefined\n        ? (currentOptions[route.name] as { stringify?: StringifyConfig })\n            .stringify\n        : undefined;\n\n    const params = route.params\n      ? // Stringify all of the param values before we use them\n        Object.entries(route.params).reduce<{\n          [key: string]: string;\n        }>((acc, [key, value]) => {\n          acc[key] = config?.[key] ? config[key](value) : String(value);\n          return acc;\n        }, {})\n      : undefined;\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = p.replace(/^:/, '').replace(/\\?$/, '');\n\n          // If the path has a pattern for a param, put the param in the path\n          if (params && name in params && p.startsWith(':')) {\n            const value = params[name];\n            // Remove the used value from the params object since we'll use the rest for query string\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete params[name];\n            return encodeURIComponent(value);\n          } else if (p.endsWith('?')) {\n            // optional params without value assigned in route.params should be ignored\n            return '';\n          }\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (params) {\n      for (let param in params) {\n        if (params[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete params[param];\n        }\n      }\n      const query = queryString.stringify(params);\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n"]},"metadata":{},"sourceType":"module"}